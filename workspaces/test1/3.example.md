# 打泡泡游戏示例和参考

---

## 🎮 游戏界面示例

### 主菜单界面
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>泡泡射击游戏</title>
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
    <div class="game-container">
        <!-- 主菜单 -->
        <div id="main-menu" class="menu-screen">
            <h1 class="game-title">🫧 泡泡射击</h1>
            <div class="menu-buttons">
                <button class="btn btn-primary" id="start-game">开始游戏</button>
                <button class="btn btn-secondary" id="level-select">选择关卡</button>
                <button class="btn btn-secondary" id="settings">设置</button>
                <button class="btn btn-secondary" id="help">帮助</button>
            </div>
            <div class="high-score">
                <p>最高分: <span id="high-score-value">0</span></p>
            </div>
        </div>
        
        <!-- 游戏界面 -->
        <div id="game-screen" class="game-screen hidden">
            <div class="game-header">
                <div class="score-info">
                    <span>分数: <span id="current-score">0</span></span>
                    <span>关卡: <span id="current-level">1</span></span>
                </div>
                <div class="game-controls">
                    <button class="btn btn-small" id="pause-btn">⏸️</button>
                    <button class="btn btn-small" id="restart-btn">🔄</button>
                </div>
            </div>
            
            <canvas id="game-canvas" width="800" height="600"></canvas>
            
            <div class="game-footer">
                <div class="next-bubble">
                    <span>下一个:</span>
                    <div id="next-bubble-preview"></div>
                </div>
                <div class="power-meter">
                    <div class="power-bar">
                        <div id="power-fill"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
```

### CSS样式示例
```css
/* main.css */
:root {
    --primary-color: #667eea;
    --secondary-color: #764ba2;
    --accent-color: #ff6b6b;
    --text-color: #333;
    --bg-gradient: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
}

body {
    margin: 0;
    padding: 0;
    font-family: 'Arial', sans-serif;
    background: var(--bg-gradient);
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: center;
}

.game-container {
    width: 100%;
    max-width: 900px;
    margin: 0 auto;
    padding: 20px;
    box-sizing: border-box;
}

.menu-screen {
    background: rgba(255, 255, 255, 0.95);
    border-radius: 20px;
    padding: 40px;
    text-align: center;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
}

.game-title {
    font-size: 3rem;
    color: var(--primary-color);
    margin-bottom: 30px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
}

.btn {
    padding: 12px 24px;
    border: none;
    border-radius: 25px;
    font-size: 1.1rem;
    cursor: pointer;
    transition: all 0.3s ease;
    margin: 8px;
    min-width: 150px;
}

.btn-primary {
    background: var(--accent-color);
    color: white;
}

.btn-primary:hover {
    background: #ff5252;
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(255, 107, 107, 0.4);
}

.btn-secondary {
    background: var(--primary-color);
    color: white;
}

.btn-secondary:hover {
    background: #5a6fd8;
    transform: translateY(-2px);
}

#game-canvas {
    border: 3px solid var(--primary-color);
    border-radius: 10px;
    background: linear-gradient(to bottom, #87ceeb, #e0f6ff);
    display: block;
    margin: 0 auto;
}

.hidden {
    display: none;
}

/* 响应式设计 */
@media (max-width: 768px) {
    .game-container {
        padding: 10px;
    }
    
    .game-title {
        font-size: 2rem;
    }
    
    .btn {
        min-width: 120px;
        font-size: 1rem;
    }
    
    #game-canvas {
        width: 100%;
        height: auto;
    }
}
```

---

## 🎯 游戏逻辑示例

### 主游戏类
```javascript
// main.js
class BubbleGame {
    constructor() {
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.gameState = 'menu';
        this.score = 0;
        this.level = 1;
        this.highScore = localStorage.getItem('bubbleGameHighScore') || 0;
        
        this.bubbleGrid = new BubbleGrid(12, 8);
        this.shooter = new Shooter(400, 550);
        this.audioManager = new AudioManager();
        this.particleSystem = new ParticleSystem();
        
        this.init();
    }
    
    init() {
        this.setupEventListeners();
        this.loadAssets();
        this.initLevel();
        this.gameLoop();
    }
    
    setupEventListeners() {
        // 鼠标事件
        this.canvas.addEventListener('mousemove', (e) => {
            if (this.gameState === 'playing') {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                this.shooter.aim(x, y);
            }
        });
        
        this.canvas.addEventListener('click', (e) => {
            if (this.gameState === 'playing') {
                this.shoot();
            }
        });
        
        // 触摸事件
        this.canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (this.gameState === 'playing') {
                const touch = e.touches[0];
                const rect = this.canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                this.shooter.aim(x, y);
                this.shoot();
            }
        });
        
        // 键盘事件
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && this.gameState === 'playing') {
                e.preventDefault();
                this.shoot();
            }
        });
    }
    
    shoot() {
        const bubble = this.shooter.shoot();
        if (bubble) {
            this.audioManager.playSound('shoot');
            this.movingBubbles.push(bubble);
        }
    }
    
    gameLoop() {
        this.update();
        this.render();
        requestAnimationFrame(() => this.gameLoop());
    }
    
    update() {
        if (this.gameState !== 'playing') return;
        
        // 更新移动的泡泡
        this.updateMovingBubbles();
        
        // 更新粒子系统
        this.particleSystem.update();
        
        // 检查游戏结束条件
        this.checkGameOver();
    }
    
    render() {
        // 清空画布
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // 渲染背景
        this.renderBackground();
        
        if (this.gameState === 'playing') {
            // 渲染游戏元素
            this.bubbleGrid.render(this.ctx);
            this.shooter.render(this.ctx);
            this.renderMovingBubbles();
            this.particleSystem.render(this.ctx);
            this.renderUI();
        }
    }
}

// 启动游戏
window.addEventListener('load', () => {
    new BubbleGame();
});
```

### 泡泡类示例
```javascript
// Bubble.js
class Bubble {
    constructor(x, y, color, radius = 20) {
        this.x = x;
        this.y = y;
        this.originalX = x;
        this.originalY = y;
        this.color = color;
        this.radius = radius;
        this.vx = 0;
        this.vy = 0;
        this.state = 'static'; // static, moving, falling, exploding
        this.animationFrame = 0;
        this.glowIntensity = 0;
    }
    
    update() {
        switch (this.state) {
            case 'moving':
                this.x += this.vx;
                this.y += this.vy;
                break;
                
            case 'falling':
                this.vy += 0.5; // 重力加速度
                this.x += this.vx * 0.98; // 空气阻力
                this.y += this.vy;
                
                // 旋转效果
                this.rotation = (this.rotation || 0) + 0.1;
                break;
                
            case 'exploding':
                this.animationFrame++;
                this.glowIntensity = Math.sin(this.animationFrame * 0.3) * 0.5 + 0.5;
                
                if (this.animationFrame > 20) {
                    this.state = 'destroyed';
                }
                break;
                
            case 'static':
                // 轻微的呼吸动画
                this.glowIntensity = Math.sin(Date.now() * 0.002) * 0.1 + 0.1;
                break;
        }
    }
    
    render(ctx) {
        if (this.state === 'destroyed') return;
        
        ctx.save();
        
        // 应用变换
        ctx.translate(this.x, this.y);
        if (this.rotation) {
            ctx.rotate(this.rotation);
        }
        
        // 爆炸效果
        if (this.state === 'exploding') {
            const scale = 1 + (this.animationFrame / 20) * 0.5;
            const alpha = 1 - (this.animationFrame / 20);
            ctx.globalAlpha = alpha;
            ctx.scale(scale, scale);
        }
        
        // 发光效果
        if (this.glowIntensity > 0) {
            ctx.shadowColor = this.color;
            ctx.shadowBlur = this.glowIntensity * 20;
        }
        
        // 绘制主体
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        
        // 绘制高光
        const gradient = ctx.createRadialGradient(-5, -5, 0, -5, -5, this.radius * 0.7);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // 绘制边框
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.restore();
    }
    
    // 检查与另一个泡泡的碰撞
    collidesWith(other) {
        const dx = this.x - other.x;
        const dy = this.y - other.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < (this.radius + other.radius);
    }
    
    // 获取颜色的RGB值
    getColorRGB() {
        const colors = {
            '#FF6B6B': [255, 107, 107],
            '#FFB347': [255, 179, 71],
            '#FFD93D': [255, 217, 61],
            '#6BCF7F': [107, 207, 127],
            '#4ECDC4': [78, 205, 196],
            '#A8E6CF': [168, 230, 207],
            '#FFB3BA': [255, 179, 186]
        };
        return colors[this.color] || [255, 255, 255];
    }
}
```

---

## 🎵 音效和动画示例

### 音效管理
```javascript
// AudioManager.js
class AudioManager {
    constructor() {
        this.sounds = {
            shoot: 'assets/sounds/shoot.mp3',
            pop: 'assets/sounds/pop.mp3',
            drop: 'assets/sounds/drop.mp3',
            levelComplete: 'assets/sounds/level-complete.mp3',
            gameOver: 'assets/sounds/game-over.mp3'
        };
        
        this.audioElements = {};
        this.enabled = true;
        this.volume = 0.7;
        
        this.loadSounds();
    }
    
    loadSounds() {
        for (const [name, src] of Object.entries(this.sounds)) {
            const audio = new Audio(src);
            audio.preload = 'auto';
            audio.volume = this.volume;
            this.audioElements[name] = audio;
        }
    }
    
    playSound(name, volume = 1.0) {
        if (!this.enabled) return;
        
        const audio = this.audioElements[name];
        if (audio) {
            audio.currentTime = 0;
            audio.volume = this.volume * volume;
            audio.play().catch(e => console.log('Audio play failed:', e));
        }
    }
    
    setVolume(volume) {
        this.volume = Math.max(0, Math.min(1, volume));
        for (const audio of Object.values(this.audioElements)) {
            audio.volume = this.volume;
        }
    }
    
    toggle() {
        this.enabled = !this.enabled;
        return this.enabled;
    }
}
```

### 粒子效果系统
```javascript
// ParticleSystem.js
class Particle {
    constructor() {
        this.reset();
    }
    
    reset() {
        this.x = 0;
        this.y = 0;
        this.vx = 0;
        this.vy = 0;
        this.life = 0;
        this.maxLife = 0;
        this.color = '#ffffff';
        this.size = 1;
        this.alpha = 1;
    }
    
    init(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.life = this.maxLife = 30 + Math.random() * 20;
        this.size = 2 + Math.random() * 3;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = (Math.random() - 0.5) * 8 - 2;
        this.alpha = 1;
    }
    
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.2; // 重力
        this.vx *= 0.98; // 阻力
        
        this.life--;
        this.alpha = this.life / this.maxLife;
        this.size *= 0.98;
        
        return this.life > 0;
    }
    
    render(ctx) {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

class ParticleSystem {
    constructor() {
        this.particles = [];
        this.pool = [];
    }
    
    createExplosion(x, y, color, count = 15) {
        for (let i = 0; i < count; i++) {
            const particle = this.getParticle();
            particle.init(x, y, color);
            this.particles.push(particle);
        }
    }
    
    createTrail(x, y, color) {
        const particle = this.getParticle();
        particle.init(x, y, color);
        particle.life = particle.maxLife = 10;
        particle.size = 1;
        this.particles.push(particle);
    }
    
    update() {
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const particle = this.particles[i];
            if (!particle.update()) {
                this.particles.splice(i, 1);
                this.returnParticle(particle);
            }
        }
    }
    
    render(ctx) {
        for (const particle of this.particles) {
            particle.render(ctx);
        }
    }
    
    getParticle() {
        return this.pool.pop() || new Particle();
    }
    
    returnParticle(particle) {
        particle.reset();
        this.pool.push(particle);
    }
}
```

---

## 📊 关卡数据示例

### 关卡配置
```javascript
// levels.js
const LEVELS = [
    {
        id: 1,
        name: "初学者",
        bubbles: [
            ['red', 'blue', 'red', 'blue', 'red', 'blue', 'red', 'blue'],
            ['blue', 'red', 'blue', 'red', 'blue', 'red', 'blue'],
            ['red', 'blue', 'red', 'blue', 'red', 'blue', 'red', 'blue'],
            ['blue', 'red', 'blue', 'red', 'blue', 'red', 'blue']
        ],
        colors: ['red', 'blue'],
        targetScore: 1000,
        timeLimit: null
    },
    
    {
        id: 2,
        name: "彩虹挑战",
        bubbles: [
            ['red', 'orange', 'yellow', 'green', 'blue', 'purple', 'red', 'orange'],
            ['orange', 'yellow', 'green', 'blue', 'purple', 'red', 'orange'],
            ['yellow', 'green', 'blue', 'purple', 'red', 'orange', 'yellow', 'green'],
            ['green', 'blue', 'purple', 'red', 'orange', 'yellow', 'green'],
            ['blue', 'purple', 'red', 'orange', 'yellow', 'green', 'blue', 'purple']
        ],
        colors: ['red', 'orange', 'yellow', 'green', 'blue', 'purple'],
        targetScore: 2500,
        timeLimit: 180
    },
    
    {
        id: 3,
        name: "精确射击",
        bubbles: [
            [null, null, 'red', 'red', 'red', null, null, null],
            [null, 'blue', 'blue', 'red', 'blue', 'blue', null],
            ['green', 'green', null, 'red', null, 'green', 'green', null],
            [null, 'yellow', 'yellow', 'red', 'yellow', 'yellow'],
            [null, null, 'purple', 'purple', 'purple', null, null, null]
        ],
        colors: ['red', 'blue', 'green', 'yellow', 'purple'],
        targetScore: 3000,
        timeLimit: 120,
        specialRules: {
            limitedShots: 20,
            noWallBounce: true
        }
    }
];

// 动态生成关卡
function generateRandomLevel(difficulty = 1) {
    const colors = ['red', 'blue', 'green', 'yellow', 'orange', 'purple'];
    const rows = 4 + Math.floor(difficulty / 2);
    const cols = 8;
    const colorCount = Math.min(3 + difficulty, colors.length);
    const levelColors = colors.slice(0, colorCount);
    
    const bubbles = [];
    for (let row = 0; row < rows; row++) {
        const bubbleRow = [];
        const colCount = cols - (row % 2);
        
        for (let col = 0; col < colCount; col++) {
            // 随机决定是否放置泡泡
            if (Math.random() < 0.8) {
                const color = levelColors[Math.floor(Math.random() * levelColors.length)];
                bubbleRow.push(color);
            } else {
                bubbleRow.push(null);
            }
        }
        bubbles.push(bubbleRow);
    }
    
    return {
        id: `random_${difficulty}`,
        name: `随机关卡 ${difficulty}`,
        bubbles,
        colors: levelColors,
        targetScore: 1000 * difficulty,
        timeLimit: Math.max(60, 180 - difficulty * 10)
    };
}
```

---

## 🎯 游戏配置示例

### 游戏常量
```javascript
// config.js
const GAME_CONFIG = {
    // 画布设置
    CANVAS_WIDTH: 800,
    CANVAS_HEIGHT: 600,
    
    // 泡泡设置
    BUBBLE_RADIUS: 20,
    BUBBLE_COLORS: [
        '#FF6B6B', // 红色
        '#FFB347', // 橙色
        '#FFD93D', // 黄色
        '#6BCF7F', // 绿色
        '#4ECDC4', // 青色
        '#A8E6CF', // 浅绿
        '#FFB3BA'  // 粉色
    ],
    
    // 网格设置
    GRID_ROWS: 12,
    GRID_COLS: 8,
    HEX_OFFSET_X: 20,
    HEX_OFFSET_Y: 17.32, // sqrt(3) * radius
    
    // 物理设置
    GRAVITY: 0.5,
    FRICTION: 0.98,
    BOUNCE_RESTITUTION: 0.8,
    SHOOT_SPEED: 12,
    
    // 游戏规则
    MIN_MATCH_COUNT: 3,
    SCORE_PER_BUBBLE: 10,
    COMBO_MULTIPLIER: 1.5,
    DROP_BONUS: 5,
    
    // 动画设置
    EXPLOSION_DURATION: 20,
    FALL_ACCELERATION: 0.5,
    PARTICLE_COUNT: 15,
    
    // 音效设置
    SOUND_VOLUME: 0.7,
    MUSIC_VOLUME: 0.4,
    
    // 控制设置
    AIM_SENSITIVITY: 1.0,
    TOUCH_THRESHOLD: 10,
    
    // 性能设置
    TARGET_FPS: 60,
    MAX_PARTICLES: 200,
    OBJECT_POOL_SIZE: 100
};

// 难度设置
const DIFFICULTY_SETTINGS = {
    easy: {
        colors: 4,
        timeLimit: null,
        aimAssist: true,
        trajectoryPreview: true
    },
    
    normal: {
        colors: 5,
        timeLimit: 300,
        aimAssist: true,
        trajectoryPreview: false
    },
    
    hard: {
        colors: 6,
        timeLimit: 180,
        aimAssist: false,
        trajectoryPreview: false,
        limitedShots: true
    },
    
    expert: {
        colors: 7,
        timeLimit: 120,
        aimAssist: false,
        trajectoryPreview: false,
        limitedShots: true,
        movingTarget: true
    }
};
```

这些示例文件提供了完整的游戏开发参考，包括：

1. **界面设计**: HTML结构和CSS样式
2. **游戏逻辑**: 核心类和算法实现
3. **音效系统**: 音频管理和播放
4. **粒子效果**: 视觉特效实现
5. **关卡数据**: 关卡配置和生成
6. **游戏配置**: 常量和设置参数

现在我们有了完整的项目需求和技术规范，可以使用智能体系统来实现这个游戏了！
