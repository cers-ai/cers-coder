# 打泡泡游戏技术规范

---

## 🏗️ 技术架构

### 整体架构
```
┌─────────────────────────────────────┐
│           用户界面层                │
│  ┌─────────────┐ ┌─────────────┐   │
│  │   游戏UI    │ │   菜单UI    │   │
│  └─────────────┘ └─────────────┘   │
├─────────────────────────────────────┤
│           游戏逻辑层                │
│  ┌─────────────┐ ┌─────────────┐   │
│  │  游戏引擎   │ │  状态管理   │   │
│  └─────────────┘ └─────────────┘   │
├─────────────────────────────────────┤
│           渲染引擎层                │
│  ┌─────────────┐ ┌─────────────┐   │
│  │ Canvas渲染  │ │  动画系统   │   │
│  └─────────────┘ └─────────────┘   │
├─────────────────────────────────────┤
│           基础服务层                │
│  ┌─────────────┐ ┌─────────────┐   │
│  │  音频管理   │ │  资源加载   │   │
│  └─────────────┘ └─────────────┘   │
└─────────────────────────────────────┘
```

### 核心模块设计

#### 1. 游戏引擎 (GameEngine)
```javascript
class GameEngine {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.gameState = 'menu'; // menu, playing, paused, gameover
        this.bubbleGrid = new BubbleGrid();
        this.shooter = new Shooter();
        this.physics = new PhysicsEngine();
        this.score = 0;
        this.level = 1;
    }
    
    // 游戏主循环
    gameLoop() {
        this.update();
        this.render();
        requestAnimationFrame(() => this.gameLoop());
    }
    
    // 更新游戏状态
    update() {
        if (this.gameState === 'playing') {
            this.physics.update();
            this.bubbleGrid.update();
            this.shooter.update();
            this.checkCollisions();
            this.checkWinCondition();
        }
    }
    
    // 渲染游戏画面
    render() {
        this.clearCanvas();
        this.bubbleGrid.render(this.ctx);
        this.shooter.render(this.ctx);
        this.renderUI();
    }
}
```

#### 2. 泡泡网格系统 (BubbleGrid)
```javascript
class BubbleGrid {
    constructor(rows = 10, cols = 12) {
        this.rows = rows;
        this.cols = cols;
        this.grid = [];
        this.bubbleRadius = 20;
        this.hexOffset = this.bubbleRadius * Math.sqrt(3) / 2;
        this.initGrid();
    }
    
    // 六边形网格布局
    getPosition(row, col) {
        const x = col * this.bubbleRadius * 2 + (row % 2) * this.bubbleRadius;
        const y = row * this.hexOffset;
        return { x, y };
    }
    
    // 添加泡泡到网格
    addBubble(row, col, color) {
        if (this.isValidPosition(row, col)) {
            const pos = this.getPosition(row, col);
            this.grid[row][col] = new Bubble(pos.x, pos.y, color);
        }
    }
    
    // 检查连通的相同颜色泡泡
    findConnectedBubbles(row, col, color, visited = new Set()) {
        const key = `${row},${col}`;
        if (visited.has(key)) return [];
        
        const bubble = this.grid[row][col];
        if (!bubble || bubble.color !== color) return [];
        
        visited.add(key);
        let connected = [{ row, col }];
        
        // 检查六个相邻位置
        const neighbors = this.getNeighbors(row, col);
        for (const [nRow, nCol] of neighbors) {
            connected = connected.concat(
                this.findConnectedBubbles(nRow, nCol, color, visited)
            );
        }
        
        return connected;
    }
}
```

#### 3. 物理引擎 (PhysicsEngine)
```javascript
class PhysicsEngine {
    constructor() {
        this.gravity = 0.5;
        this.friction = 0.98;
        this.bounceRestitution = 0.8;
    }
    
    // 圆形碰撞检测
    checkCircleCollision(circle1, circle2) {
        const dx = circle1.x - circle2.x;
        const dy = circle1.y - circle2.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < (circle1.radius + circle2.radius);
    }
    
    // 计算反弹轨迹
    calculateTrajectory(startX, startY, angle, speed, maxSteps = 100) {
        const trajectory = [];
        let x = startX;
        let y = startY;
        let vx = Math.cos(angle) * speed;
        let vy = Math.sin(angle) * speed;
        
        for (let i = 0; i < maxSteps; i++) {
            x += vx;
            y += vy;
            
            // 边界反弹
            if (x <= 0 || x >= canvas.width) {
                vx = -vx;
                x = Math.max(0, Math.min(canvas.width, x));
            }
            
            trajectory.push({ x, y });
            
            // 如果到达顶部区域，停止计算
            if (y <= 0) break;
        }
        
        return trajectory;
    }
}
```

#### 4. 泡泡类 (Bubble)
```javascript
class Bubble {
    constructor(x, y, color, radius = 20) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.radius = radius;
        this.vx = 0;
        this.vy = 0;
        this.state = 'static'; // static, moving, falling, exploding
        this.animationFrame = 0;
    }
    
    // 更新泡泡状态
    update() {
        switch (this.state) {
            case 'moving':
                this.x += this.vx;
                this.y += this.vy;
                break;
            case 'falling':
                this.vy += 0.5; // 重力
                this.x += this.vx;
                this.y += this.vy;
                break;
            case 'exploding':
                this.animationFrame++;
                if (this.animationFrame > 30) {
                    this.state = 'destroyed';
                }
                break;
        }
    }
    
    // 渲染泡泡
    render(ctx) {
        if (this.state === 'destroyed') return;
        
        ctx.save();
        
        if (this.state === 'exploding') {
            // 爆炸动画
            const scale = 1 + (this.animationFrame / 30) * 0.5;
            const alpha = 1 - (this.animationFrame / 30);
            ctx.globalAlpha = alpha;
            ctx.scale(scale, scale);
        }
        
        // 绘制泡泡
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        
        // 高光效果
        ctx.beginPath();
        ctx.arc(this.x - 5, this.y - 5, this.radius * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.fill();
        
        ctx.restore();
    }
}
```

---

## 🎮 游戏逻辑实现

### 射击系统
```javascript
class Shooter {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.angle = 0;
        this.currentBubble = this.generateRandomBubble();
        this.nextBubble = this.generateRandomBubble();
        this.power = 10;
        this.trajectory = [];
    }
    
    // 瞄准
    aim(targetX, targetY) {
        this.angle = Math.atan2(targetY - this.y, targetX - this.x);
        this.trajectory = this.calculateTrajectory();
    }
    
    // 发射泡泡
    shoot() {
        if (!this.currentBubble) return null;
        
        const bubble = this.currentBubble;
        bubble.vx = Math.cos(this.angle) * this.power;
        bubble.vy = Math.sin(this.angle) * this.power;
        bubble.state = 'moving';
        
        // 切换到下一个泡泡
        this.currentBubble = this.nextBubble;
        this.nextBubble = this.generateRandomBubble();
        
        return bubble;
    }
}
```

### 消除算法
```javascript
class BubbleEliminator {
    // 检查并消除连通的泡泡
    static eliminateBubbles(grid, row, col) {
        const bubble = grid.getBubble(row, col);
        if (!bubble) return { eliminated: [], dropped: [] };
        
        // 找出所有连通的相同颜色泡泡
        const connected = grid.findConnectedBubbles(row, col, bubble.color);
        
        if (connected.length >= 3) {
            // 消除泡泡
            const eliminated = [];
            for (const pos of connected) {
                const bubble = grid.removeBubble(pos.row, pos.col);
                if (bubble) {
                    bubble.state = 'exploding';
                    eliminated.push(bubble);
                }
            }
            
            // 检查掉落的泡泡
            const dropped = this.findDroppedBubbles(grid);
            
            return { eliminated, dropped };
        }
        
        return { eliminated: [], dropped: [] };
    }
    
    // 找出失去支撑的泡泡
    static findDroppedBubbles(grid) {
        const visited = new Set();
        const connected = new Set();
        
        // 从顶行开始，标记所有连通的泡泡
        for (let col = 0; col < grid.cols; col++) {
            if (grid.getBubble(0, col)) {
                this.markConnected(grid, 0, col, visited, connected);
            }
        }
        
        // 收集未连通的泡泡（即将掉落）
        const dropped = [];
        for (let row = 0; row < grid.rows; row++) {
            for (let col = 0; col < grid.cols; col++) {
                const key = `${row},${col}`;
                const bubble = grid.getBubble(row, col);
                if (bubble && !connected.has(key)) {
                    bubble.state = 'falling';
                    dropped.push(bubble);
                    grid.removeBubble(row, col);
                }
            }
        }
        
        return dropped;
    }
}
```

---

## 🎨 渲染系统

### Canvas渲染优化
```javascript
class Renderer {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCtx = this.offscreenCanvas.getContext('2d');
        this.dirtyRegions = [];
    }
    
    // 只重绘变化区域
    renderDirtyRegions() {
        for (const region of this.dirtyRegions) {
            this.ctx.clearRect(region.x, region.y, region.width, region.height);
            // 重绘该区域的内容
            this.renderRegion(region);
        }
        this.dirtyRegions = [];
    }
    
    // 预渲染静态元素
    prerenderStaticElements() {
        this.offscreenCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        // 渲染背景、UI等静态元素到离屏Canvas
        this.renderBackground(this.offscreenCtx);
        this.renderUI(this.offscreenCtx);
    }
}
```

### 粒子效果系统
```javascript
class ParticleSystem {
    constructor() {
        this.particles = [];
        this.pool = []; // 对象池
    }
    
    // 创建爆炸效果
    createExplosion(x, y, color, count = 10) {
        for (let i = 0; i < count; i++) {
            const particle = this.getParticle();
            particle.init(x, y, color);
            particle.vx = (Math.random() - 0.5) * 10;
            particle.vy = (Math.random() - 0.5) * 10;
            particle.life = 30;
            this.particles.push(particle);
        }
    }
    
    // 对象池管理
    getParticle() {
        return this.pool.pop() || new Particle();
    }
    
    returnParticle(particle) {
        particle.reset();
        this.pool.push(particle);
    }
}
```

---

## 🔊 音频系统

### Web Audio API实现
```javascript
class AudioManager {
    constructor() {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.sounds = new Map();
        this.masterVolume = 1.0;
        this.sfxVolume = 0.8;
        this.musicVolume = 0.6;
    }
    
    // 加载音频文件
    async loadSound(name, url) {
        try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
            this.sounds.set(name, audioBuffer);
        } catch (error) {
            console.error(`Failed to load sound: ${name}`, error);
        }
    }
    
    // 播放音效
    playSound(name, volume = 1.0) {
        const audioBuffer = this.sounds.get(name);
        if (!audioBuffer) return;
        
        const source = this.audioContext.createBufferSource();
        const gainNode = this.audioContext.createGain();
        
        source.buffer = audioBuffer;
        gainNode.gain.value = volume * this.sfxVolume * this.masterVolume;
        
        source.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        source.start();
    }
}
```

---

## 📱 响应式设计

### 自适应Canvas
```javascript
class ResponsiveCanvas {
    constructor(canvas) {
        this.canvas = canvas;
        this.baseWidth = 800;
        this.baseHeight = 600;
        this.scale = 1;
        this.setupResponsive();
    }
    
    setupResponsive() {
        const resize = () => {
            const container = this.canvas.parentElement;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            const scaleX = containerWidth / this.baseWidth;
            const scaleY = containerHeight / this.baseHeight;
            this.scale = Math.min(scaleX, scaleY);
            
            this.canvas.style.width = `${this.baseWidth * this.scale}px`;
            this.canvas.style.height = `${this.baseHeight * this.scale}px`;
            
            // 保持Canvas内部分辨率
            this.canvas.width = this.baseWidth;
            this.canvas.height = this.baseHeight;
        };
        
        window.addEventListener('resize', resize);
        resize();
    }
}
```

---

## 🧪 测试框架

### 单元测试示例
```javascript
// 使用Jest进行单元测试
describe('BubbleGrid', () => {
    let grid;
    
    beforeEach(() => {
        grid = new BubbleGrid(10, 12);
    });
    
    test('should create grid with correct dimensions', () => {
        expect(grid.rows).toBe(10);
        expect(grid.cols).toBe(12);
    });
    
    test('should calculate correct hexagonal positions', () => {
        const pos1 = grid.getPosition(0, 0);
        const pos2 = grid.getPosition(1, 0);
        
        expect(pos1.x).toBe(0);
        expect(pos1.y).toBe(0);
        expect(pos2.x).toBe(20); // offset for odd row
    });
    
    test('should find connected bubbles correctly', () => {
        grid.addBubble(0, 0, 'red');
        grid.addBubble(0, 1, 'red');
        grid.addBubble(0, 2, 'red');
        
        const connected = grid.findConnectedBubbles(0, 0, 'red');
        expect(connected.length).toBe(3);
    });
});
```

---

## 🚀 构建和部署

### Webpack配置
```javascript
module.exports = {
    entry: './src/js/main.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
    },
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: 'babel-loader'
            },
            {
                test: /\.css$/,
                use: ['style-loader', 'css-loader']
            },
            {
                test: /\.(png|jpg|gif|svg)$/,
                use: 'file-loader'
            },
            {
                test: /\.(mp3|wav)$/,
                use: 'file-loader'
            }
        ]
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: './src/index.html'
        }),
        new CleanWebpackPlugin()
    ]
};
```

### PWA配置
```javascript
// service-worker.js
const CACHE_NAME = 'bubble-game-v1';
const urlsToCache = [
    '/',
    '/css/main.css',
    '/js/bundle.js',
    '/assets/images/',
    '/assets/sounds/'
];

self.addEventListener('install', event => {
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(cache => cache.addAll(urlsToCache))
    );
});

self.addEventListener('fetch', event => {
    event.respondWith(
        caches.match(event.request)
            .then(response => response || fetch(event.request))
    );
});
```
