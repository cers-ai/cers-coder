# æ‰“æ³¡æ³¡æ¸¸æˆæŠ€æœ¯è§„èŒƒ

---

## ğŸ—ï¸ æŠ€æœ¯æ¶æ„

### æ•´ä½“æ¶æ„
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           ç”¨æˆ·ç•Œé¢å±‚                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   æ¸¸æˆUI    â”‚ â”‚   èœå•UI    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           æ¸¸æˆé€»è¾‘å±‚                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  æ¸¸æˆå¼•æ“   â”‚ â”‚  çŠ¶æ€ç®¡ç†   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           æ¸²æŸ“å¼•æ“å±‚                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Canvasæ¸²æŸ“  â”‚ â”‚  åŠ¨ç”»ç³»ç»Ÿ   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           åŸºç¡€æœåŠ¡å±‚                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  éŸ³é¢‘ç®¡ç†   â”‚ â”‚  èµ„æºåŠ è½½   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒæ¨¡å—è®¾è®¡

#### 1. æ¸¸æˆå¼•æ“ (GameEngine)
```javascript
class GameEngine {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.gameState = 'menu'; // menu, playing, paused, gameover
        this.bubbleGrid = new BubbleGrid();
        this.shooter = new Shooter();
        this.physics = new PhysicsEngine();
        this.score = 0;
        this.level = 1;
    }
    
    // æ¸¸æˆä¸»å¾ªç¯
    gameLoop() {
        this.update();
        this.render();
        requestAnimationFrame(() => this.gameLoop());
    }
    
    // æ›´æ–°æ¸¸æˆçŠ¶æ€
    update() {
        if (this.gameState === 'playing') {
            this.physics.update();
            this.bubbleGrid.update();
            this.shooter.update();
            this.checkCollisions();
            this.checkWinCondition();
        }
    }
    
    // æ¸²æŸ“æ¸¸æˆç”»é¢
    render() {
        this.clearCanvas();
        this.bubbleGrid.render(this.ctx);
        this.shooter.render(this.ctx);
        this.renderUI();
    }
}
```

#### 2. æ³¡æ³¡ç½‘æ ¼ç³»ç»Ÿ (BubbleGrid)
```javascript
class BubbleGrid {
    constructor(rows = 10, cols = 12) {
        this.rows = rows;
        this.cols = cols;
        this.grid = [];
        this.bubbleRadius = 20;
        this.hexOffset = this.bubbleRadius * Math.sqrt(3) / 2;
        this.initGrid();
    }
    
    // å…­è¾¹å½¢ç½‘æ ¼å¸ƒå±€
    getPosition(row, col) {
        const x = col * this.bubbleRadius * 2 + (row % 2) * this.bubbleRadius;
        const y = row * this.hexOffset;
        return { x, y };
    }
    
    // æ·»åŠ æ³¡æ³¡åˆ°ç½‘æ ¼
    addBubble(row, col, color) {
        if (this.isValidPosition(row, col)) {
            const pos = this.getPosition(row, col);
            this.grid[row][col] = new Bubble(pos.x, pos.y, color);
        }
    }
    
    // æ£€æŸ¥è¿é€šçš„ç›¸åŒé¢œè‰²æ³¡æ³¡
    findConnectedBubbles(row, col, color, visited = new Set()) {
        const key = `${row},${col}`;
        if (visited.has(key)) return [];
        
        const bubble = this.grid[row][col];
        if (!bubble || bubble.color !== color) return [];
        
        visited.add(key);
        let connected = [{ row, col }];
        
        // æ£€æŸ¥å…­ä¸ªç›¸é‚»ä½ç½®
        const neighbors = this.getNeighbors(row, col);
        for (const [nRow, nCol] of neighbors) {
            connected = connected.concat(
                this.findConnectedBubbles(nRow, nCol, color, visited)
            );
        }
        
        return connected;
    }
}
```

#### 3. ç‰©ç†å¼•æ“ (PhysicsEngine)
```javascript
class PhysicsEngine {
    constructor() {
        this.gravity = 0.5;
        this.friction = 0.98;
        this.bounceRestitution = 0.8;
    }
    
    // åœ†å½¢ç¢°æ’æ£€æµ‹
    checkCircleCollision(circle1, circle2) {
        const dx = circle1.x - circle2.x;
        const dy = circle1.y - circle2.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        return distance < (circle1.radius + circle2.radius);
    }
    
    // è®¡ç®—åå¼¹è½¨è¿¹
    calculateTrajectory(startX, startY, angle, speed, maxSteps = 100) {
        const trajectory = [];
        let x = startX;
        let y = startY;
        let vx = Math.cos(angle) * speed;
        let vy = Math.sin(angle) * speed;
        
        for (let i = 0; i < maxSteps; i++) {
            x += vx;
            y += vy;
            
            // è¾¹ç•Œåå¼¹
            if (x <= 0 || x >= canvas.width) {
                vx = -vx;
                x = Math.max(0, Math.min(canvas.width, x));
            }
            
            trajectory.push({ x, y });
            
            // å¦‚æœåˆ°è¾¾é¡¶éƒ¨åŒºåŸŸï¼Œåœæ­¢è®¡ç®—
            if (y <= 0) break;
        }
        
        return trajectory;
    }
}
```

#### 4. æ³¡æ³¡ç±» (Bubble)
```javascript
class Bubble {
    constructor(x, y, color, radius = 20) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.radius = radius;
        this.vx = 0;
        this.vy = 0;
        this.state = 'static'; // static, moving, falling, exploding
        this.animationFrame = 0;
    }
    
    // æ›´æ–°æ³¡æ³¡çŠ¶æ€
    update() {
        switch (this.state) {
            case 'moving':
                this.x += this.vx;
                this.y += this.vy;
                break;
            case 'falling':
                this.vy += 0.5; // é‡åŠ›
                this.x += this.vx;
                this.y += this.vy;
                break;
            case 'exploding':
                this.animationFrame++;
                if (this.animationFrame > 30) {
                    this.state = 'destroyed';
                }
                break;
        }
    }
    
    // æ¸²æŸ“æ³¡æ³¡
    render(ctx) {
        if (this.state === 'destroyed') return;
        
        ctx.save();
        
        if (this.state === 'exploding') {
            // çˆ†ç‚¸åŠ¨ç”»
            const scale = 1 + (this.animationFrame / 30) * 0.5;
            const alpha = 1 - (this.animationFrame / 30);
            ctx.globalAlpha = alpha;
            ctx.scale(scale, scale);
        }
        
        // ç»˜åˆ¶æ³¡æ³¡
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        
        // é«˜å…‰æ•ˆæœ
        ctx.beginPath();
        ctx.arc(this.x - 5, this.y - 5, this.radius * 0.3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.fill();
        
        ctx.restore();
    }
}
```

---

## ğŸ® æ¸¸æˆé€»è¾‘å®ç°

### å°„å‡»ç³»ç»Ÿ
```javascript
class Shooter {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.angle = 0;
        this.currentBubble = this.generateRandomBubble();
        this.nextBubble = this.generateRandomBubble();
        this.power = 10;
        this.trajectory = [];
    }
    
    // ç„å‡†
    aim(targetX, targetY) {
        this.angle = Math.atan2(targetY - this.y, targetX - this.x);
        this.trajectory = this.calculateTrajectory();
    }
    
    // å‘å°„æ³¡æ³¡
    shoot() {
        if (!this.currentBubble) return null;
        
        const bubble = this.currentBubble;
        bubble.vx = Math.cos(this.angle) * this.power;
        bubble.vy = Math.sin(this.angle) * this.power;
        bubble.state = 'moving';
        
        // åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªæ³¡æ³¡
        this.currentBubble = this.nextBubble;
        this.nextBubble = this.generateRandomBubble();
        
        return bubble;
    }
}
```

### æ¶ˆé™¤ç®—æ³•
```javascript
class BubbleEliminator {
    // æ£€æŸ¥å¹¶æ¶ˆé™¤è¿é€šçš„æ³¡æ³¡
    static eliminateBubbles(grid, row, col) {
        const bubble = grid.getBubble(row, col);
        if (!bubble) return { eliminated: [], dropped: [] };
        
        // æ‰¾å‡ºæ‰€æœ‰è¿é€šçš„ç›¸åŒé¢œè‰²æ³¡æ³¡
        const connected = grid.findConnectedBubbles(row, col, bubble.color);
        
        if (connected.length >= 3) {
            // æ¶ˆé™¤æ³¡æ³¡
            const eliminated = [];
            for (const pos of connected) {
                const bubble = grid.removeBubble(pos.row, pos.col);
                if (bubble) {
                    bubble.state = 'exploding';
                    eliminated.push(bubble);
                }
            }
            
            // æ£€æŸ¥æ‰è½çš„æ³¡æ³¡
            const dropped = this.findDroppedBubbles(grid);
            
            return { eliminated, dropped };
        }
        
        return { eliminated: [], dropped: [] };
    }
    
    // æ‰¾å‡ºå¤±å»æ”¯æ’‘çš„æ³¡æ³¡
    static findDroppedBubbles(grid) {
        const visited = new Set();
        const connected = new Set();
        
        // ä»é¡¶è¡Œå¼€å§‹ï¼Œæ ‡è®°æ‰€æœ‰è¿é€šçš„æ³¡æ³¡
        for (let col = 0; col < grid.cols; col++) {
            if (grid.getBubble(0, col)) {
                this.markConnected(grid, 0, col, visited, connected);
            }
        }
        
        // æ”¶é›†æœªè¿é€šçš„æ³¡æ³¡ï¼ˆå³å°†æ‰è½ï¼‰
        const dropped = [];
        for (let row = 0; row < grid.rows; row++) {
            for (let col = 0; col < grid.cols; col++) {
                const key = `${row},${col}`;
                const bubble = grid.getBubble(row, col);
                if (bubble && !connected.has(key)) {
                    bubble.state = 'falling';
                    dropped.push(bubble);
                    grid.removeBubble(row, col);
                }
            }
        }
        
        return dropped;
    }
}
```

---

## ğŸ¨ æ¸²æŸ“ç³»ç»Ÿ

### Canvasæ¸²æŸ“ä¼˜åŒ–
```javascript
class Renderer {
    constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.offscreenCanvas = document.createElement('canvas');
        this.offscreenCtx = this.offscreenCanvas.getContext('2d');
        this.dirtyRegions = [];
    }
    
    // åªé‡ç»˜å˜åŒ–åŒºåŸŸ
    renderDirtyRegions() {
        for (const region of this.dirtyRegions) {
            this.ctx.clearRect(region.x, region.y, region.width, region.height);
            // é‡ç»˜è¯¥åŒºåŸŸçš„å†…å®¹
            this.renderRegion(region);
        }
        this.dirtyRegions = [];
    }
    
    // é¢„æ¸²æŸ“é™æ€å…ƒç´ 
    prerenderStaticElements() {
        this.offscreenCtx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        // æ¸²æŸ“èƒŒæ™¯ã€UIç­‰é™æ€å…ƒç´ åˆ°ç¦»å±Canvas
        this.renderBackground(this.offscreenCtx);
        this.renderUI(this.offscreenCtx);
    }
}
```

### ç²’å­æ•ˆæœç³»ç»Ÿ
```javascript
class ParticleSystem {
    constructor() {
        this.particles = [];
        this.pool = []; // å¯¹è±¡æ± 
    }
    
    // åˆ›å»ºçˆ†ç‚¸æ•ˆæœ
    createExplosion(x, y, color, count = 10) {
        for (let i = 0; i < count; i++) {
            const particle = this.getParticle();
            particle.init(x, y, color);
            particle.vx = (Math.random() - 0.5) * 10;
            particle.vy = (Math.random() - 0.5) * 10;
            particle.life = 30;
            this.particles.push(particle);
        }
    }
    
    // å¯¹è±¡æ± ç®¡ç†
    getParticle() {
        return this.pool.pop() || new Particle();
    }
    
    returnParticle(particle) {
        particle.reset();
        this.pool.push(particle);
    }
}
```

---

## ğŸ”Š éŸ³é¢‘ç³»ç»Ÿ

### Web Audio APIå®ç°
```javascript
class AudioManager {
    constructor() {
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        this.sounds = new Map();
        this.masterVolume = 1.0;
        this.sfxVolume = 0.8;
        this.musicVolume = 0.6;
    }
    
    // åŠ è½½éŸ³é¢‘æ–‡ä»¶
    async loadSound(name, url) {
        try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
            this.sounds.set(name, audioBuffer);
        } catch (error) {
            console.error(`Failed to load sound: ${name}`, error);
        }
    }
    
    // æ’­æ”¾éŸ³æ•ˆ
    playSound(name, volume = 1.0) {
        const audioBuffer = this.sounds.get(name);
        if (!audioBuffer) return;
        
        const source = this.audioContext.createBufferSource();
        const gainNode = this.audioContext.createGain();
        
        source.buffer = audioBuffer;
        gainNode.gain.value = volume * this.sfxVolume * this.masterVolume;
        
        source.connect(gainNode);
        gainNode.connect(this.audioContext.destination);
        
        source.start();
    }
}
```

---

## ğŸ“± å“åº”å¼è®¾è®¡

### è‡ªé€‚åº”Canvas
```javascript
class ResponsiveCanvas {
    constructor(canvas) {
        this.canvas = canvas;
        this.baseWidth = 800;
        this.baseHeight = 600;
        this.scale = 1;
        this.setupResponsive();
    }
    
    setupResponsive() {
        const resize = () => {
            const container = this.canvas.parentElement;
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            const scaleX = containerWidth / this.baseWidth;
            const scaleY = containerHeight / this.baseHeight;
            this.scale = Math.min(scaleX, scaleY);
            
            this.canvas.style.width = `${this.baseWidth * this.scale}px`;
            this.canvas.style.height = `${this.baseHeight * this.scale}px`;
            
            // ä¿æŒCanvaså†…éƒ¨åˆ†è¾¨ç‡
            this.canvas.width = this.baseWidth;
            this.canvas.height = this.baseHeight;
        };
        
        window.addEventListener('resize', resize);
        resize();
    }
}
```

---

## ğŸ§ª æµ‹è¯•æ¡†æ¶

### å•å…ƒæµ‹è¯•ç¤ºä¾‹
```javascript
// ä½¿ç”¨Jestè¿›è¡Œå•å…ƒæµ‹è¯•
describe('BubbleGrid', () => {
    let grid;
    
    beforeEach(() => {
        grid = new BubbleGrid(10, 12);
    });
    
    test('should create grid with correct dimensions', () => {
        expect(grid.rows).toBe(10);
        expect(grid.cols).toBe(12);
    });
    
    test('should calculate correct hexagonal positions', () => {
        const pos1 = grid.getPosition(0, 0);
        const pos2 = grid.getPosition(1, 0);
        
        expect(pos1.x).toBe(0);
        expect(pos1.y).toBe(0);
        expect(pos2.x).toBe(20); // offset for odd row
    });
    
    test('should find connected bubbles correctly', () => {
        grid.addBubble(0, 0, 'red');
        grid.addBubble(0, 1, 'red');
        grid.addBubble(0, 2, 'red');
        
        const connected = grid.findConnectedBubbles(0, 0, 'red');
        expect(connected.length).toBe(3);
    });
});
```

---

## ğŸš€ æ„å»ºå’Œéƒ¨ç½²

### Webpacké…ç½®
```javascript
module.exports = {
    entry: './src/js/main.js',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'bundle.js'
    },
    module: {
        rules: [
            {
                test: /\.js$/,
                exclude: /node_modules/,
                use: 'babel-loader'
            },
            {
                test: /\.css$/,
                use: ['style-loader', 'css-loader']
            },
            {
                test: /\.(png|jpg|gif|svg)$/,
                use: 'file-loader'
            },
            {
                test: /\.(mp3|wav)$/,
                use: 'file-loader'
            }
        ]
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: './src/index.html'
        }),
        new CleanWebpackPlugin()
    ]
};
```

### PWAé…ç½®
```javascript
// service-worker.js
const CACHE_NAME = 'bubble-game-v1';
const urlsToCache = [
    '/',
    '/css/main.css',
    '/js/bundle.js',
    '/assets/images/',
    '/assets/sounds/'
];

self.addEventListener('install', event => {
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(cache => cache.addAll(urlsToCache))
    );
});

self.addEventListener('fetch', event => {
    event.respondWith(
        caches.match(event.request)
            .then(response => response || fetch(event.request))
    );
});
```
